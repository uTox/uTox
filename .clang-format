BasedOnStyle: LLVM

ColumnLimit: 120
IndentWidth: 4
TabWidth: 4
UseTab: Never

AlignConsecutiveAssignments: true
AlignConsecutiveDeclarations: true
AlignTrailingComments: true

AllowShortBlocksOnASingleLine: false
AllowShortCaseLabelsOnASingleLine: true
AllowShortIfStatementsOnASingleLine: false
AllowShortLoopsOnASingleLine: false
AllowShortFunctionsOnASingleLine: None

# The function definition return type breaking style to use.
# Possible values:
#     DRTBS_None     (in configuration: None) Break after return type automatically.
#     PenaltyReturnTypeOnItsOwnLine is taken into account.
#     DRTBS_All      (in configuration: All) Always break after the return type.
#     DRTBS_TopLevel (in configuration: TopLevel) Always break after the return types
#     of top level functions.
#  "AlwaysBreakAfterDefinitionReturnType": "None",

# If true, always break before multiline string literals.
# This flag is mean to make cases where there are multiple multiline
# strings in a file look more consistent. Thus, it will only take effect
# if wrapping the string at that point leads to it being indented
# ContinuationIndentWidth spaces from the start of the line.
#  "AlwaysBreakBeforeMultilineStrings": true,

# If true, always break after the template<...> of a template declaration.
#  "AlwaysBreakTemplateDeclarations": true,

# If false, a function call’s arguments will either be all on the same line
# or will have one line each.
#  "BinPackArguments": true,

# If false, a function call’s or function definition’s parameters will
# either all be on the same line or will have one line each.
#  "BinPackParameters": true,

# Control of individual brace wrapping cases.
# If BreakBeforeBraces is set to custom, use this to specify how each
# individual brace case should be handled. Otherwise, this is ignored.
# Nested configuration flags:
# bool AfterClass Wrap class definitions.
# bool AfterControlStatement Wrap control statements (if/for/while/switch/..).
# bool AfterEnum Wrap enum definitions.
# bool AfterFunction Wrap function definitions.
# bool AfterNamespace Wrap namespace definitions.
# bool AfterObjCDeclaration Wrap ObjC definitions (@autoreleasepool, interfaces, ..).
# bool AfterStruct Wrap struct definitions.
# bool AfterUnion Wrap union definitions.
# bool BeforeCatch Wrap before catch.
# bool BeforeElse Wrap before else.
# bool IndentBraces Indent the wrapped braces themselves.
# "BraceWrapping": "IndentBraces",

# Break after each annotation on a field in Java files.
# "BreakAfterJavaFieldAnnotations": true,

BreakBeforeBinaryOperators: NonAssignment
BreakBeforeBraces: Attach

# If true, ternary operators will be placed after line breaks.
#  "BreakBeforeTernaryOperators": true,

# Always break constructor initializers before commas and align the commas
# with the colon.
#  "BreakConstructorInitializersBeforeComma": true,

# A regular expression that describes comments with special meaning, which
# should not be split into lines or otherwise changed.
# "CommentPragmas": "",

# If the constructor initializers don’t fit on a line, put each initializer
# on its own line.
#  "ConstructorInitializerAllOnOneLineOrOnePerLine": true,

# The number of characters to use for indentation of constructor
# initializer lists.
#  "ConstructorInitializerIndentWidth": 2,

# Indent width for line continuations.
#  "ContinuationIndentWidth": 2,

# If true, format braced lists as best suited for C++11 braced lists.
# Important "differences": - No spaces inside the braced list. - No line
# break before the closing brace. - Indentation with the continuation
# indent, not with the block indent. Fundamentally, C++11 braced lists are
# formatted exactly like function calls would be formatted in their place.
# If the braced list follows a name (e.g. a type or variable name), clang-
# format formats as if the {} were the parentheses of a function call with
# that name. If there is no name, a zero-length name is assumed.
#  "Cpp11BracedListStyle": true,

# If true, analyze the formatted file for the most common alignment of
# & and *. PointerAlignment is then used only as fallback.
#  "DerivePointerAlignment": true,

# Disables formatting completely.
#  "DisableFormat": false,

# If true, clang-format detects whether function calls and definitions are
# formatted with one parameter per line. Each call can be bin-packed, one-
# per-line or inconclusive. If it is inconclusive, e.g. completely on one
# line, but a decision needs to be made, clang-format analyzes whether
# there are other bin-packed cases in the input file and act accordingly.
# "NOTE": This is an experimental flag, that might go away or be renamed. Do
# not use this in config files, etc. Use at your own risk.
#  "ExperimentalAutoDetectBinPacking": true,

# A vector of macros that should be interpreted as foreach loops instead of
# as function calls. These are expected to be macros of the "form":
# FOREACH(<variable-declaration>, ...)
# <loop-body>
# In the .clang-format configuration file, this can be configured like:
# ForEachMacros: ['RANGES_FOR', 'FOREACH']
# For example: BOOST_FOREACH.
# "ForEachMacros": "['RANGES_FOR', 'FOREACH']"

# Regular expressions denoting the different #include categories used for
# ordering #includes.
# These regular expressions are matched against the filename of an include
# (including the <> or “”) in order. The value belonging to the first
# matching regular expression is assigned and #includes are sorted first
# according to increasing category number and then alphabetically within
# each category.
# If none of the regular expressions match, UINT_MAX is assigned as
# category. The main header for a source file automatically gets
# category 0, so that it is kept at the beginning of the
# #includes (http://llvm.org/docs/CodingStandards.html#include-style).
# To configure this in the .clang-format file, use:
# IncludeCategories:
#   - Regex:           '^"(llvm|llvm-c|clang|clang-c)/'
#     Priority:        2
#   - Regex:           '^(<|"(gtest|isl|json)/)'
#     Priority:        3
#   - Regex:           '.\*'
#     Priority:        1
# "IncludeCategories": "UINT_MAX"

# Indent case labels one level from the switch statement. When false, use
# the same indentation level as for the switch statement. Switch statement
# body is always indented one level more than case labels.
IndentCaseLabels: true

# If true, indent when breaking function declarations which are not also
# definitions after the type.
#  "IndentFunctionDeclarationAfterType": true,

# Indent if a function definition or declaration is wrapped after the type.
#  "IndentWrappedFunctionNames": true,

# If true, empty lines at the start of blocks are kept.
# "KeepEmptyLinesAtTheStartOfBlocks": true,

# Language, this format style is targeted at. Possible "values": LK_None
# (in "configuration": None) Do not use. LK_Cpp (in "configuration": Cpp)
# Should be used for C, C++, ObjectiveC, ObjectiveC++. LK_JavaScript (in
# "configuration": JavaScript) Should be used for JavaScript. LK_Proto (in
# "configuration": Proto) Should be used for Protocol Buffers
# ("https"://developers.google.com/protocol-buffers/).
#  "Language": "Cpp",

# A regular expression matching macros that start a block.
#  MacroBlockBegin: "*_MACRO_START"

# A regular expression matching macros that end a block.
#  MacroBlockEnd: "*_MACRO_END",

# The maximum number of consecutive empty lines to keep.
#  "MaxEmptyLinesToKeep": 2,

# The number of characters to use for indentation of ObjC blocks.
#  "ObjCBlockIndentWidth": 4,

# Add a space after @property in Objective-C, i.e. use @property (readonly)
# instead of @property(readonly).
#  "ObjCSpaceAfterProperty": false,

# Add a space in front of an Objective-C protocol list, i.e. use Foo
# <Protocol> instead of Foo<Protocol>.
#  "ObjCSpaceBeforeProtocolList": false,

# The penalty for breaking a function call after “call(”.
PenaltyBreakBeforeFirstCallParameter: 10

# The penalty for each line break introduced inside a comment.
PenaltyBreakComment: 3

# The penalty for breaking before the first <<.
#  "PenaltyBreakFirstLessLess": 0,

# The penalty for each line break introduced inside a string literal.
#  "PenaltyBreakString": 0,

# The penalty for each character outside of the column limit.
#  "PenaltyExcessCharacter": 0,

# Penalty for putting the return type of a function onto its own line.
#  "PenaltyReturnTypeOnItsOwnLine": 0,

PointerAlignment: Right

SpaceAfterCStyleCast: false
SortIncludes: false # I'd like this to be true eventually TODO

# If false, spaces will be removed before assignment operators.
SpaceBeforeAssignmentOperators: true
SpaceBeforeParens: ControlStatements
SpaceInEmptyParentheses: false

# The number of spaces before trailing line comments (//-comments). This
# does not affect trailing block comments (/**/-comments) as those commonly
# have different usage patterns and a number of special cases.
#  "SpacesBeforeTrailingComments": 2,

# If true, spaces will be inserted after ‘<’ and before ‘>’ in template
# argument lists
#  "SpacesInAngles": true,

# If true, spaces may be inserted into C style casts.
#  "SpacesInCStyleCastParentheses": true,

# If true, spaces will be inserted after ‘(‘ and before ‘)’.
#  "SpacesInParentheses": true,

# If true, spaces will be inserted after ‘[‘ and before ‘]’.
#  "SpacesInSquareBrackets": true,
